#!/bin/sh
# SPDX-License-Identifier: GPL-2.0

ATOMICDIR=$(dirname $0)

. ${ATOMICDIR}/atomic-tbl.sh

#gen_param_check(meta, arg)
gen_param_check()
{
	local meta="$1"; shift
	local arg="$1"; shift
	local type="${arg%%:*}"
	local name="$(gen_param_name "${arg}")"
	local rw="write"

	case "${type#c}" in
	i) return;;
	esac

	if [ ${type#c} != ${type} ]; then
		# We don't write to constant parameters.
		rw="read"
	elif [ "${meta}" != "s" ]; then
		# An atomic RMW: if this parameter is not a constant, and this atomic is
		# not just a 's'tore, this parameter is both read from and written to.
		rw="read_write"
	fi

	printf "\tinstrument_atomic_${rw}(${name}, sizeof(*${name}));\n"
}

#gen_params_checks(meta, arg...)
gen_params_checks()
{
	local meta="$1"; shift
	local order="$1"; shift

	if [ "${order}" = "_release" ]; then
		printf "\tkssb_flush_release();\n"
		printf "\tkcsan_release();\n"
	elif [ "${order}" = "_acquire" ]; then
		printf "\tkssb_flush_acquire();\n"
	elif [ -z "${order}" ] && ! meta_in "$meta" "slv"; then
		# RMW with return value is fully ordered
		printf "\tkssb_flush();\n"
		printf "\tkcsan_mb();\n"
	fi

	while [ "$#" -gt 0 ]; do
		gen_param_check "$meta" "$1"
		shift;
	done
}

#gen_proto_order_variant(meta, pfx, name, sfx, order, atomic, int, arg...)
gen_proto_order_variant()
{
	local meta="$1"; shift
	local pfx="$1"; shift
	local name="$1"; shift
	local sfx="$1"; shift
	local order="$1"; shift
	local atomic="$1"; shift
	local int="$1"; shift

	local atomicname="${atomic}_${pfx}${name}${sfx}${order}"

	local ret="$(gen_ret_type "${meta}" "${int}")"
	local params="$(gen_params "${int}" "${atomic}" "$@")"
	local checks="$(gen_params_checks "${meta}" "${order}" "$@")"
	local args="$(gen_args "$@")"
	local retstmt="$(gen_ret_stmt "${meta}")"

	gen_kerneldoc "" "${meta}" "${pfx}" "${name}" "${sfx}" "${order}" "${atomic}" "${int}" "$@"

cat <<EOF
static __always_inline ${ret}
${atomicname}(${params})
{
${checks}
	${retstmt}raw_${atomicname}(${args});
}
EOF

	printf "\n"
}

gen_xchg()
{
	local xchg="$1"; shift
	local order="$1"; shift

	kcsan_barrier=""
	if [ "${xchg%_local}" = "${xchg}" ]; then
		case "$order" in
		_release)	kcsan_barrier="kcsan_release()" ;;
		"")			kcsan_barrier="kcsan_mb()" ;;
		esac
	fi

	kssb_flush=""
	if [ "${xchg%_local}" = "${xchg}" ]; then
		case "$order" in
		_release)	kssb_flush="kssb_flush_release()" ;;
		_acquire)	kssb_flush="kssb_flush_acquire()" ;;
		"")			kssb_flush="kssb_flush()" ;;
		esac
	fi

	if [ "${xchg%${xchg#try_cmpxchg}}" = "try_cmpxchg" ] ; then

cat <<EOF
#define ${xchg}${order}(ptr, oldp, ...) \\
({ \\
	typeof(ptr) __ai_ptr = (ptr); \\
	typeof(oldp) __ai_oldp = (oldp); \\
EOF
[ -n "$kssb_flush" ] && printf "\t${kssb_flush}; \\\\\n"
[ -n "$kcsan_barrier" ] && printf "\t${kcsan_barrier}; \\\\\n"
cat <<EOF
	instrument_atomic_read_write(__ai_ptr, sizeof(*__ai_ptr)); \\
	instrument_read_write(__ai_oldp, sizeof(*__ai_oldp)); \\
	raw_${xchg}${order}(__ai_ptr, __ai_oldp, __VA_ARGS__); \\
})
EOF

	else

cat <<EOF
#define ${xchg}${order}(ptr, ...) \\
({ \\
	typeof(ptr) __ai_ptr = (ptr); \\
EOF
[ -n "$kssb_flush" ] && printf "\t${kssb_flush}; \\\\\n"
[ -n "$kcsan_barrier" ] && printf "\t${kcsan_barrier}; \\\\\n"
cat <<EOF
	instrument_atomic_read_write(__ai_ptr, sizeof(*__ai_ptr)); \\
	raw_${xchg}${order}(__ai_ptr, __VA_ARGS__); \\
})
EOF

	fi
}

cat << EOF
// SPDX-License-Identifier: GPL-2.0

// Generated by $0
// DO NOT MODIFY THIS FILE DIRECTLY

/*
 * This file provoides atomic operations with explicit instrumentation (e.g.
 * KASAN, KCSAN), which should be used unless it is necessary to avoid
 * instrumentation. Where it is necessary to aovid instrumenation, the
 * raw_atomic*() operations should be used.
 */
#ifndef _LINUX_ATOMIC_INSTRUMENTED_H
#define _LINUX_ATOMIC_INSTRUMENTED_H

#include <linux/build_bug.h>
#include <linux/compiler.h>
#include <linux/instrumented.h>

// As atomic operations flush the store buffer because we instrument
// them, we need to avoid flushing the store buffer in emulating the
// store buffer. For those files, define NO_INSTRUMENT_ATOMIC.
#if defined(CONFIG_KSSB) && !defined(NO_INSTRUMENT_ATOMIC)
// XXX: We don't want to emulate TSO, so use PSO here
extern void __ssb_pso_flush(void);
#define kssb_flush() __ssb_pso_flush()
#define kssb_lfence() __ssb_pso_lfence()
#else
#define kssb_flush() do {} while(0)
#define kssb_lfence() do {} while(0)
#endif

#define kssb_flush_release() kssb_flush()
#define kssb_flush_acquire() kssb_lfence()

EOF

grep '^[a-z]' "$1" | while read name meta args; do
	gen_proto "${meta}" "${name}" "atomic" "int" ${args}
done

grep '^[a-z]' "$1" | while read name meta args; do
	gen_proto "${meta}" "${name}" "atomic64" "s64" ${args}
done

grep '^[a-z]' "$1" | while read name meta args; do
	gen_proto "${meta}" "${name}" "atomic_long" "long" ${args}
done


for xchg in "xchg" "cmpxchg" "cmpxchg64" "cmpxchg128" "try_cmpxchg" "try_cmpxchg64" "try_cmpxchg128"; do
	for order in "" "_acquire" "_release" "_relaxed"; do
		gen_xchg "${xchg}" "${order}"
		printf "\n"
	done
done

for xchg in "cmpxchg_local" "cmpxchg64_local" "cmpxchg128_local" "sync_cmpxchg" \
	    "try_cmpxchg_local" "try_cmpxchg64_local" "try_cmpxchg128_local" "sync_try_cmpxchg"; do
	gen_xchg "${xchg}" ""
	printf "\n"
done

cat <<EOF

#endif /* _LINUX_ATOMIC_INSTRUMENTED_H */
EOF
